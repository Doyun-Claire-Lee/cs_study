# 페이지 교체 정책

### 페이지 교체 과정
1. 프로세스가 데이터 접근을 위해 메모리 관리자에게 데이터 요청
2. 해당 데이터가 메모리에 없으면 Page Fault 인터럽트 발생
3. 해당 프로세스는 대기상태로 변환되고 요청받은 데이터를 메모리에 올림(스왑 인)
4. 이때 페이지를 스왑영역에서 메모리로 불러들이는데, 메모리에 공간이 없을 경우 어떤 페이지를 스왑영역으로 보낼지(스왑 아웃)를 페이지 교체 정책에 따름.

### 페이지 교체 정책
1. Random: 무작위 선택 교체, 자주 사용되는 페이지가 교체될 수도 있어 성능이 좋지 않아 잘 사용되지 않음.
2. FIFO: 메모리에 들어온 지 가장 오래된 페이지를 교체, 자주 사용되는 페이지가 교체 될 가능성이 존재하지만 구현이 간단하고 성능이 괜찮아 변형해서 많이 쓰임.
3. Optimum: 앞으로 가장 오랫동안 쓰이지 않을 페이지를 교체, 사실상 구현이 불가능한 이론적인 방법. 다른 알고리즘과의 성능 비교용으로 쓰임
4. LRU: 최근 가장 사용이 적은 페이지 교체, 시간의 지역성 이론에 따름. Optimum 알고리즘에 근접한 성능을 보이지만 프로그램이 지역성을 띄지 않을땐 성능이 떨어지는 단점

### 빌레이디의 역설
- Page fault를 줄이려고 메모리를 더 늘려서 프레임의 수를 늘렸는데 오히려 Page fault가 더 많이 발생하는 현상
- FIFO 에서만 발생하고 LRU에서는 발생하지 않음
- LRU 구현시의 문제점: 
  - 1. 시간을 기록하는 비트가 필요, 많은 비트가 있어도 시간이 아주 오래 지난다고 가정하면 어쩔수없이 오버플로우가 발생하게 됨.
  - 2. 오버플로우로 값이 초기화되면서 시간을 제대로 표현할 수 없게 됨.
- LRU 구현시의 문제점을 해결하기 위해 클락 알고리즘이 고안됨.

### 클락 알고리즘
- 접근비트 하나만을 이용하여 시간을 표현
- 일정 시간마다 모든 비트의 접근비트를 0으로 초기화
- 접근비트의 초기값은 0, 페이지가 참조되었다면 1
- 페이지를 원형으로 연결, 스왑영역으로 옮길 페이지를 포인터(클락핸드)로 가르킴
- 클락핸드는 시계방향으로 회전
- Page fault가 발생해서 스왑아웃이 필요한 경우 클락핸드는 현재 페이지의 접근비트를 확인하여 접근비트가 0이라면 1로 바꾸고 다음 페이지를 가르킴.
- 반복하다가 접근비트가 0인 페이지를 발견하면 해당 페이지를 스왑영역으로 보냄.

### 향상된 클락 알고리즘
- 접근비트와 변경비트 사용
- 스왑아웃 순위가 가장 높은것은 접근비트와 변경비트 모두 0인 페이지
- (0, 0), (0, 1), (1, 0), (1, 1)의 순서대로 교체

### 개선된 FIFO
> 하드웨어적으로 접근비트를 지원하지 않는 시스템에서는 LRU 대신 FIFO를 이용할 수 밖에 없음
- 2차기회 페이지 교체 알고리즘: 자주 사용되는 페이지에게는 또한번의 기회를 주는 방식
- 만약 Page fault없이 페이지 접근에 성공했다면 해당 페이지를 큐의 맨 뒤로 이동시켜 수명을 연장시켜주는 방식
- 성능은 LRU보다는 떨어지지만 FIFO보다는 높음